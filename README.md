# fl-auction
take home task for fl's interview

# Real-Time Auction System

A production-ready real-time auction platform built with Go, GraphQL, and React featuring WebSocket-based live updates and extended bidding functionality.

## 📋 Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Architecture](#architecture)
- [Tech Stack](#tech-stack)
- [Project Structure](#project-structure)
- [Getting Started](#getting-started)
- [Backend Setup](#backend-setup)
- [Frontend Setup](#frontend-setup)
- [Usage](#usage)
- [API Documentation](#api-documentation)
- [Testing](#testing)
- [Design Decisions](#design-decisions)
- [Future Enhancements](#future-enhancements)

---

## 🎯 Overview

This project implements a real-time auction system where users can create auctions, place bids, and receive instant updates across all connected clients through GraphQL subscriptions. The system enforces business rules like bid validation, countdown timers, and extended bidding for competitive auctions.

**Key Highlights:**
- Real-time bidding with WebSocket subscriptions
- Automatic auction expiration with countdown timers
- Extended bidding (10-second extension for last-minute bids)
- Single active auction enforcement
- Comprehensive error handling and validation
- Type-safe implementation (Go + TypeScript)

---

## ✨ Features

### Core Functionality
- ✅ **Create Auction**: Start new auctions with configurable starting bid and duration
- ✅ **Place Bids**: Real-time bid placement with validation
- ✅ **Live Updates**: Instant synchronization across all connected clients
- ✅ **Countdown Timer**: Live countdown with per-second updates
- ✅ **Extended Bidding**: Automatic 10-second extension for bids placed in final 10 seconds
- ✅ **Winner Declaration**: Automatic winner announcement when auction ends

### Business Rules
- Only one active auction at a time
- Bids must be strictly higher than current bid
- Bids after auction end are rejected
- Next bid calculation (current bid + $1)
- Configurable auction duration (default: 30 seconds)

### Technical Features
- GraphQL API with queries, mutations, and subscriptions
- WebSocket support for real-time updates
- Thread-safe concurrent operations
- Clean architecture with separation of concerns
- Comprehensive error handling
- Type safety throughout

---

## 🏗️ Architecture

### System Architecture

```
┌─────────────────┐         WebSocket/HTTP          ┌──────────────────┐
│                 │◄──────────────────────────────►│                  │
│  React Client   │         GraphQL API             │   Go Server      │
│  (TypeScript)   │                                 │   (GraphQL)      │
│                 │                                 │                  │
└─────────────────┘                                 └──────────────────┘
        │                                                    │
        │                                                    │
        ├─ Apollo Client                                    ├─ Resolver Layer
        ├─ GraphQL Subscriptions                            ├─ Service Layer
        ├─ React Hooks                                      ├─ Store Layer (Pub/Sub)
        └─ Tailwind CSS                                     └─ Domain Models
```

### Backend Architecture (Go)

```
graph/
├── schema.graphql          # GraphQL schema definition
├── schema.resolvers.go     # Resolver implementations
├── resolver.go            # Root resolver with dependencies
└── generated.go           # Auto-generated by gqlgen

internal/
├── model/                 # Domain models (source of truth)
│   ├── auction.go         # Auction entity
│   ├── bid.go            # Bid entity
│   ├── event.go          # Event types for pub/sub
│   ├── errors.go         # Custom errors
│   └── validation.go     # Business rules
│
├── store/                # Data layer
│   └── auction_store.go  # In-memory store + pub/sub
│
└── service/              # Business logic
    └── auction_service.go # Auction operations
```

**Design Pattern:** Clean Architecture
- **Domain Models**: Pure business logic, no dependencies
- **Service Layer**: Orchestrates business operations
- **Store Layer**: Data persistence and event distribution
- **Resolver Layer**: Thin GraphQL adapter

### Frontend Architecture (React)

```
src/
├── apollo/
│   └── client.ts         # Apollo Client configuration
├── graphql/
│   └── operations.ts     # GraphQL queries/mutations/subscriptions
├── components/
│   └── AuctionDashboard.tsx  # Main UI component
├── App.tsx              # App wrapper with Apollo Provider
└── main.tsx            # React entry point
```

---

## 🛠️ Tech Stack

### Backend
- **Language**: Go 1.21+
- **GraphQL**: [gqlgen](https://gqlgen.com/) - Type-safe GraphQL server
- **WebSocket**: [gorilla/websocket](https://github.com/gorilla/websocket)
- **CORS**: [rs/cors](https://github.com/rs/cors)

### Frontend
- **Framework**: React 18+ with TypeScript
- **Build Tool**: Vite
- **GraphQL Client**: Apollo Client 3.8+
- **Styling**: Tailwind CSS 3.3+
- **Icons**: Lucide React
- **WebSocket**: graphql-ws

### Infrastructure
- **Concurrency**: Go goroutines, channels, and mutexes
- **Pub/Sub**: Custom in-memory implementation
- **Real-time**: GraphQL subscriptions over WebSocket

---

## 📁 Project Structure

```
.
├── auction-system/              # Backend (Go)
│   ├── graph/
│   │   ├── schema.graphql
│   │   ├── schema.resolvers.go
│   │   ├── resolver.go
│   │   ├── d.go
│   │   └── model/
│   │       └── models_gen.go
│   ├── internal/
│   │   ├── model/
│   │   │   ├── auction.go
│   │   │   ├── bid.go
│   │   │   ├── event.go
│   │   │   ├── errors.go
│   │   │   └── validation.go
│   │   ├── store/
│   │   │   └── auction_store.go
│   │   └── service/
│   │       ├── auction_service.go
│   │       └── auction_service_test.go
│   ├── main.go
│   ├── gqlgen.yml
│   ├── go.mod
│   └── go.sum
│
└── auction-client/              # Frontend (React)
    ├── src/
    │   ├── apollo/
    │   │   └── client.ts
    │   ├── graphql/
    │   │   └── operations.ts
    │   ├── components/
    │   │   └── AuctionDashboard.tsx
    │   ├── App.tsx
    │   ├── main.tsx
    │   └── index.css
    ├── tailwind.config.js
    ├── postcss.config.js
    ├── package.json
    └── vite.config.ts
```

---

## 🚀 Getting Started

### Prerequisites

**Backend:**
- Go 1.21 or higher
- Make (optional)

**Frontend:**
- Node.js 18+ and npm
- Modern web browser with WebSocket support

### Quick Start

```bash
# Clone the repository
git clone <your-repo-url>
cd <repo-name>

# Start backend (Terminal 1)
cd auction-system
go run main.go

# Start frontend (Terminal 2)
cd auction-client
npm install
npm run dev
```

**Access the application:**
- Frontend: http://localhost:5173
- GraphQL Playground: http://localhost:8080
- GraphQL API: http://localhost:8080/query

---

## 🔧 Backend Setup

### 1. Initialize Go Module

```bash
cd auction-system
go mod init auction-system
```

### 2. Install Dependencies

```bash
go get github.com/99designs/gqlgen
go get github.com/gorilla/websocket
go get github.com/rs/cors
```

### 3. Generate GraphQL Code

```bash
go get github.com/99designs/gqlgen@v0.17.81
go run github.com/99designs/gqlgen generate
```

This generates:
- `graph/generated.go` - GraphQL execution engine
- `graph/model/models_gen.go` - Type definitions (minimal with autobind)
- `graph/schema.resolvers.go` - Resolver stubs (implement these)

### 4. Run the Server

```bash
go run main.go
```

Server starts on `http://localhost:8080`

### 5. Run Tests

```bash
go test ./internal/service/... -v
go test ./... -cover
```

### Configuration

Environment variables (optional):
```bash
export PORT=8080  # Server port (default: 8080)
```

---

## 💻 Frontend Setup

### 1. Create React App

```bash
npm create vite@latest auction-client -- --template react-ts
cd auction-client
```

### 2. Install Dependencies

```bash
# Core dependencies
npm install @apollo/client graphql graphql-ws lucide-react

# Development dependencies
npm install -D tailwindcss postcss autoprefixer @types/node

# Initialize Tailwind
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

### 3. Configure Files

Create/update the following files as documented in the setup guide:
- `src/apollo/client.ts`
- `src/graphql/operations.ts`
- `src/components/AuctionDashboard.tsx`
- `src/App.tsx`
- `tailwind.config.js`
- `postcss.config.js`

### 4. Run Development Server

```bash
npm run dev
```

Frontend runs on `http://localhost:5173`

### 5. Build for Production

```bash
npm run build
npm run preview
```

---

## 📖 Usage

### Creating an Auction

1. Open the application at `http://localhost:5173`
2. Click "Start New Auction" button
3. Auction starts with:
   - Starting bid: $100
   - Duration: 30 seconds
   - Extended bidding: enabled

### Placing Bids

1. Enter bid amount (must be higher than current bid)
2. Click "Bid" button
3. Success: Bid is accepted and all clients update
4. Error: Display message (too low, too late, etc.)

### Real-Time Synchronization

1. Open multiple browser tabs to `http://localhost:5173`
2. Create auction in one tab
3. All tabs see the auction instantly
4. Place bid in any tab
5. All tabs update in real-time

### Testing Extended Bidding

1. Create auction with 30-second duration
2. Wait until timer shows < 10 seconds
3. Place a bid
4. Notice timer extends to 10 seconds from bid time

---

## 📚 API Documentation

### GraphQL Schema

```graphql
type Auction {
  id: ID!
  startingBid: Float!
  currentBid: Float!
  currentWinner: String
  duration: Int!
  extendedBidding: Boolean!
  startTime: Time!
  endTime: Time!
  status: AuctionStatus!
  nextBid: Float!
  timeRemaining: Int!
}

type Bid {
  id: ID!
  auctionId: ID!
  userId: String!
  amount: Float!
  timestamp: Time!
}

type Query {
  currentAuction: Auction
  timeRemaining: Int!
}

type Mutation {
  createAuction(
    startingBid: Float!
    duration: Int
    extendedBidding: Boolean
  ): Auction!
  
  placeBid(userId: String!, amount: Float!): Bid!
}

type Subscription {
  auctionEvents: AuctionEvent!
}
```

### Example Operations

#### Create Auction
```graphql
mutation {
  createAuction(
    startingBid: 100
    duration: 30
    extendedBidding: true
  ) {
    id
    status
    currentBid
    timeRemaining
  }
}
```

#### Place Bid
```graphql
mutation {
  placeBid(userId: "user123", amount: 150) {
    id
    amount
    timestamp
  }
}
```

#### Query Current Auction
```graphql
query {
  currentAuction {
    id
    currentBid
    currentWinner
    timeRemaining
    status
  }
}
```

#### Subscribe to Events
```graphql
subscription {
  auctionEvents {
    type
    auction {
      currentBid
      currentWinner
      timeRemaining
      status
    }
    bid {
      userId
      amount
    }
  }
}
```

### Error Responses

```json
{
  "errors": [{
    "message": "bid too low: must be higher than current bid",
    "path": ["placeBid"]
  }]
}
```

Common errors:
- `bid too low` - Bid not higher than current bid
- `bid too late` - Auction has ended
- `no active auction` - No auction in progress
- `an auction is already active` - Cannot create multiple auctions

---

## 🧪 Testing

### Backend Tests

```bash
# Run all tests
go test ./...

# Run with coverage
go test ./... -cover

# Run specific package
go test ./internal/service/... -v

# Run with race detection
go test ./... -race
```

### Manual Testing with GraphQL Playground

1. Open `http://localhost:8080`
2. Test mutations, queries, and subscriptions
3. Open multiple subscription tabs to test real-time sync

### Frontend Testing

```bash
# Run dev server
npm run dev

# Build and test production build
npm run build
npm run preview
```

### Load Testing

```bash
# Install hey
go install github.com/rakyll/hey@latest

# Test concurrent connections
hey -n 100 -c 10 http://localhost:8080/query
```

---

## 🎨 Design Decisions

### Why Go?
- Excellent concurrency primitives (goroutines, channels)
- Strong type safety
- Great performance for real-time systems
- Native GraphQL support via gqlgen

### Why GraphQL?
- Single endpoint for all operations
- Real-time subscriptions over WebSocket
- Type-safe client-server contract
- Efficient data fetching

### Why In-Memory Storage?
- Simplifies implementation for demo/interview
- Demonstrates pub/sub pattern
- Easy to upgrade to Redis/PostgreSQL later
- Sufficient for interview requirements

### Why Clean Architecture?
- **Testability**: Each layer independently testable
- **Maintainability**: Clear separation of concerns
- **Scalability**: Easy to add features or swap implementations
- **Interview Appeal**: Shows architectural thinking

### Concurrency Strategy
- **RWMutex**: Read-heavy workloads (auction state)
- **Channels**: Event distribution (pub/sub)
- **Goroutines**: Background timers and cleanup
- **Context**: Graceful subscription cancellation

---

## 🚀 Future Enhancements

### Short-term
- [ ] User authentication and authorization
- [ ] Persistent storage (PostgreSQL/MongoDB)
- [ ] Auction history and analytics
- [ ] Multiple simultaneous auctions
- [ ] Bid history and audit trail
- [ ] Email notifications for winners

### Medium-term
- [ ] Redis for distributed pub/sub
- [ ] Rate limiting per user
- [ ] Websocket connection pooling
- [ ] Auction categories and search
- [ ] Reserve price (hidden minimum)
- [ ] Proxy bidding (automatic bid increases)

### Long-term
- [ ] Microservices architecture
- [ ] Kubernetes deployment
- [ ] Payment integration (Stripe)
- [ ] Mobile app (React Native)
- [ ] AI-powered price recommendations
- [ ] Fraud detection system

---

## 📝 API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/` | GET | GraphQL Playground |
| `/query` | POST | GraphQL API |
| `/query` | WebSocket | GraphQL Subscriptions |

---

## 🤝 Contributing

This is a take-home interview project. For production use:

1. Fork the repository
2. Create feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit changes (`git commit -m 'Add AmazingFeature'`)
4. Push to branch (`git push origin feature/AmazingFeature`)
5. Open Pull Request

---

## 📄 License

This project is created for educational/interview purposes.

---

## 👤 Author

Created as a staff engineer technical assessment demonstrating:
- Clean architecture and design patterns
- Real-time system implementation
- GraphQL API design
- Concurrent programming in Go
- Modern React development
- Type safety and testing
- Production-ready code quality

---

## 🙏 Acknowledgments

- [gqlgen](https://gqlgen.com/) - GraphQL server library for Go
- [Apollo Client](https://www.apollographql.com/docs/react/) - GraphQL client for React
- [Tailwind CSS](https://tailwindcss.com/) - Utility-first CSS framework
- Fanatics Live - Original auction system inspiration

---

## 📧 Contact

For questions about this implementation:
- Open an issue in the repository
- Review the inline code documentation
- Check GraphQL Playground at `http://localhost:8080`

---

## 🎯 Interview Focus Areas

This project demonstrates proficiency in:

1. **System Design**: Clean architecture, separation of concerns
2. **Concurrency**: Thread-safe operations, goroutines, channels
3. **Real-Time Systems**: WebSocket, pub/sub, event-driven architecture
4. **API Design**: GraphQL schema, resolver patterns, error handling
5. **Frontend Development**: React hooks, Apollo Client, real-time UI
6. **Testing**: Unit tests, integration tests, manual testing
7. **Code Quality**: Type safety, documentation, error handling
8. **DevOps Readiness**: Environment configuration, logging, graceful shutdown

**Key Technical Achievements:**
- ✅ Zero-downtime concurrent operations
- ✅ Sub-second real-time updates
- ✅ Type-safe end-to-end
- ✅ Comprehensive error handling
- ✅ Production-ready architecture
- ✅ Extensive documentation

---

**Built with ❤️ for technical excellence**
